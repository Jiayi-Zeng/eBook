# 3.2 汇编指令

## 3.2.1 相关概念

CPU所能识别的机器指令是一列预定义的二进制数字，对于不同的CPU这套指令并不同。当指令和数据被输入到计算机中，计算机将之转换为一列高低电平，以使得计算机的电子器件受到驱动，进行运算。

计算机上运行的一切程序，都是机器语言程序。包括操作系统和所有的应用软件。这些机器语言的程序，一般都不是直接用机器语言编写的，而是用各种或高级或低级的程序设计语言（包括汇编语言、C语言等）编写后通过翻译程序翻译成机器语言程序，然后再在硬件上运行的。

![图3.2.1程序执行示意图](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.1程序执行示意图.png)

接下来我会带你具体分析指令的执行过程。
在上面的例子中，load 指令将内存中的数据导入寄存器，我们写成了 16 进制：0x8c000100，拆分成二进制就是：

![图3.2.2](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.2.png)

所以我们是把操作码、寄存器的编号、要读取的地址合并到了一个 32 位的指令中。
我们再来看一条求加法运算的 add 指令，16 进制表示是 0x08048000，换算成二进制就是：

![图3.2.3](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.3.png)


构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。由此可见 CPU 内部有一个循环：

![图3.2.4](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.4.png)

> **选择题 3.2.1 汇编语言源程序**
> 下列关于汇编语言源程序的说法，错误的是（ ） （汇编指令可以被编译成机器指令，而伪指令没有对应的机器指令。）
>
> * 一个汇编语言源程序从写出到执行需经过：编写.asm文件→将.asm文件编译为.obj文件→将.obj文件连接成.exe文件→.exe文件执行
> * 在汇编语言源程序中，包含三种指令：汇编指令、伪指令、其他符号
> * 在汇编语言源程序中，不由编译器执行的伪指令有对应的机器指令
> * 在汇编语言源程序中，汇编指令是有对应机器码的指令，其所对应的机器指令由CPU执行
>
> 正确答案：在汇编语言源程序中，不由编译器执行的伪指令有对应的机器指令 


## 3.2.2 汇编指令

学习编程其实就是学高级语言，即那些为人类设计的计算机语言。但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。

![图3.2.5](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.5.png)

计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。

我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。这些指令都是二进制的，称为操作码（opcode），比如图3.2.3中加法指令就是000010。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。

汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令000010写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。

![图3.2.6](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.6.png)

最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。

学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。

>  **选择题 3.2.2 8086/8088 CPU的寄存器**
>  8086/8088 CPU的寄存器组中，16位的寄存器共有（ ）个。
>  * 10
>  * 12
>  * 13
>  * 14
>
>  正确答案：14

## 3.2.3 寄存器

![图3.2.7](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.7.png)

寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。
早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。

* EAX
* EBX
* ECX
* EDX
* EDI
* ESI
* EBP
* ESP

上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。

![图3.2.8](https://ebook2023.oss-cn-shanghai.aliyuncs.com/图3.2.8.png)

我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。

> **选择题 3.2.3 汇编语言编程**
进行汇编语言编程时，设计者应该考虑一些基本的要求，下列叙述不正确的是（）。
> * 程序应该结构化
> * 程序应该执行速度快
> * 程序应该占用空间大
> * 程序应该简明、易读、易懂
> 
> 正确答案：程序应该占用空间大 。

## 3.2.4 常用指令

### 1. 一个实例

了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。

```c
int main() {
    int a=2;
    int b=3;
    a=a+b;
    return a;
}
```
gcc 将这个程序转成汇编语言。
```bash
gcc -S example.c
```
上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。
example.s经过简化以后，大概是下面的样子。
```
main:
	push    esp
	mov     [esp+4], 2
	mov     [esp+8], 3
	mov     eax, [esp+8]
	add      [esp+4], eax
	mov     eax, [esp+4]
	pop     esp
	ret
```
可以看到，原程序有函数main，对应标签main。标签里面是该函数所转成的 CPU 运行流程。
每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。
```
push   esp
```
这一行里面，push是 CPU 指令，esp是该指令要用到的运算子，在这里是它存储的是栈底地址。一个 CPU 指令可以有零个到多个运算子。

下面主要讲解该汇编程序里的add指令和mov指令。

### 2. mov 指令

mov指令用于将一个值写入某个寄存器。

```
mov    [esp+8], 3
```

上面的代码将 ESP 寄存器的值加12个字节，再将3按照这个地址存在 Stack 中。
下一行代码也是干类似的事情。

```
mov    eax, [esp+8]
```

这一行代码表示，先将ESP寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是3，再将3写入 EAX 寄存器。

下面再给出2个额外的简单例子：

| 汇编指令      | 操作                           | 高级语言描述 |
| ------------- | ------------------------------ | ------------ |
| `mov eax,18`  | 将18送入寄存器EAX              | `EAX=18`     |
| `mov eax,ebx` | 将寄存器EBX中的数据送寄存器EAX | `EAX=EBX`    |

### 3. add 指令

add指令用于将两个运算子相加，并将结果写入第一个运算子。

```
add      [esp+4], eax
```

上面的代码将 EAX 寄存器的值（即3）加上Stack中地址[esp+4]处的值（即2），得到结果5，再将这个结果写入第一个运算子 [esp+4]中。

下面再给出2个额外的简单例子：

| 汇编指令      | 操作                          | 高级语言描述  |
| ------------- | ----------------------------- | ------------- |
| `add eax,8`   | 将寄存器EAX中的数值加8        | `EAX=EAX+8`   |
| `add eax,ebx` | 将EAX和EBX中的数值相加送入EAX | `EAX=EAX+EBX` |