# 1.2 计算机如何工作？

前面一节介绍了计算机是什么，我们从物理上理解了计算机是有一些基础硬件和软件构成的系统。这一节我们打开计算机的黑匣子，看看从逻辑层面计算机是如何构成的，程序是什么，以及程序怎么在计算机上来执行。

## 1.2.1 打开计算机的黑匣子

### **(1)**   **数据处理器**

图1.1.18是最常见的PC机。简单来说，计算机就是一个得到一定的输入，执行一些运算，并反馈一个结果的设备。那么我们可以把计算机用如下逻辑结构来表示。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.1 计算机数据处理器模型.png" alt="图1.2.1 计算机数据处理器模型" loading="lazy" />

如果按照上图来抽象计算机，那显然计算器也是计算机，定义过于宽泛。上述结构中，缺少了软件或程序部分。如果考虑程序，则计算机可以抽象成如下结构。

### **(2)**   **可编程数据处理器**

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.2计算机可编程数据处理器模型.png" alt="图1.2.2 计算机可编程数据处理器模型" loading="lazy" />

它表示在程序的指导之下，对输入数据进行处理，并得到输出数据。对于该系统而言，有两个输入，即数据和程序，它们都是可变的。下面，我们来看几个具体例子。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.3计算机可编程数据处理器计算案例.png" alt="图1.2.3 计算机可编程数据处理器计算案例" loading="lazy" />

> **思考与讨论**
>
> 从上述系统来看，我们可以分别讨论：
>
> (1)   输入相同，程序不同：我们可以得到相同或者不同的结果
>
> (2)   输入不同，程序相同：我们可以得到相同或者不同的结果
>
> (3)   输入不同，程序不同：我们可以得到相同或者不同的结果
>
> 问题：对于输入相同，程序相同的情况，我们会得到什么样的结果？
>
> 讨论：
>
> * 假设输入是一个序列，程序是寻找最大值，则输入确定必然导致输出确定；
>
> * 假设输入是一个序列，程序是随机挑一个数输出，则情况变得想到复杂。如给定序列，1，3，3，4，则第一次运行程序可能输出3，第二次运行程序可能输出3也可能输出1或4，显然从这个角度看，是给定输入，输出可能相同也可能不同。但是如果我们确定随机数的种子，要求前后运行时随机种子（即所有的物理情况）也相同，则输出结果必然相同。

从上面的结果来分析，程序给计算机带来了极大的灵活性，我们可以在给定的计算机硬件上通过改变程序，而让计算机处理不同的事情，比如播放视频、处理图像等等。

### **(3)**   **冯诺依曼模型**

计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去。直至遇到停止指令。程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型。这一原理最初是由美籍匈牙利数学家冯.诺依曼于1945年提出来的，故称为冯.诺依曼计算机模型。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.4 冯.诺依曼计算机模型.png" alt="图1.2.4 冯.诺依曼计算机模型" loading="lazy" />

**(3.1) 输入设备**

输入设备是用来向计算机输入命令、程序、数据、文本、图形、图像、音频和视频等信息的设备，并将它们转换成计算机能接受的形式（二进制数）存放到内存中。常见的输入设备有键盘、鼠标、扫描仪、光笔、数字化仪等。

**(3.2)** **运算器**

运算器也称为算术逻辑单元ALU（Arithmetic Logic Unit），是计算机中执行各种算术和逻辑运算操作的部件。其功能是进行算术运算（如加、减、乘、除）和逻辑运算（如逻辑加、逻辑乘和非运算）。运算器处理的数据来自存储器；处理后的结果数据通常被送回存储器，或暂时寄存在运算器中。

**(3.3)** **控制器**

控制器（Control Unit，CU）根据事先给定的命令发出控制信息，使整个电脑指令执行过程一步一步地进行，是计算机的神经中枢。控制器是计算机的神经中枢和指挥中心，负责统一指挥计算机各部分协调地工作，负责决定程序的执行顺序，给出机器各部件需要的操作控制命令，基本功能就是从内存取指令和执行指令。

**(3.4)** **中央处理器**

中央处理器（Central Processing Unit，CPU）又称微处理器（Microprocessor），主要包括运算器（ALU）和控制器（CU）两大部分，是计算机的核心部件。它的品质直接影响计算机系统的性能。它和内存构成了计算机的主机，是计算机的主体。我们可以简单地理解为：

**CPU＝运算器+控制器**

CPU的性能指标主要有字长和时钟主频两个。随着CPU主频的不断提高，它对内存的存取速度更快了，为了协调CPU和内存之间的速度差异问题，在CPU芯片中又集成了高速缓冲存储器（Cache），高速缓冲存储器也是对比CPU品质的重要指标，它的存储量越大，中央处理器的运算速度越快。

为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。

如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；

如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。

这里的 32 和 64，称作 CPU 的位宽。

为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。

**(3.5)** **存储器**

存储器（Memory）是计算机系统中的记忆设备，用来存放程序、数据与结果。所以存储器应该具有存数和取数的功能。计算机的存储器分为两类：一类是设在主机中的内部存储器（内存），也叫主存储器（主存），用于存放当前运行的程序和程序所用的数据，属于临时存储器；另一类属于计算机外部设备的存储器，叫外部存储器（外存），也叫辅助存储器（辅存），用于存放暂时不用的数据和程序，属于永久性存储器，当需要时应先调入内存。

**(3.6)** **输出设备**

输出设备是人与计算机交互的一种部件，用于数据的输出，可以将存放在内存中的数据或信息以数字、字符、图像、声音等形式表现出来。常见的输出设备有显示器、打印机、绘图仪等。

**(3.7)** **总线**

CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：

1. 一种是地址总线，专门用来指定 CPU 将要操作的内存地址。
2. 还有一种是数据总线，用来读写内存中的数据。当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。
3. 最后一种总线叫作控制总线，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。

> **思考与讨论**
>
> 1. 线路位宽问题
>
>  你可能会好奇数据如何通过线路传递。其实是通过操作电压，低电压是 0，高电压是 1。如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。大家注意，这种传递是相当慢的，因为你需要传递 4 次。这种一个 bit 一个 bit 发送的方式，我们叫作串行。如果希望每次多传一些数据，就需要增加线路，也就是需要并行。
>
>  如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 210 种情况，也就是可以操作 1024 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 232 是 4G。
>
>  到这里，你可能会问，那我串行发送行不行？当然也不是不行，只是速度会很慢，因为每多增加一条线路速度就会翻倍。
>
> 2. 64 位和 32 位的计算
>
>  CPU 的位宽会对计算造成什么影响？我们来看一个具体场景：要用 32 位宽的 CPU，加和两个 64 位的数字。32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。因此必须把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如用像小时候做加法竖式一样，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。
>
>  而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。但是你千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。
>
>  要知道大部分应用不需要计算超过 32 位的数字，比如你做一个电商网站，用户的金额通常是 10 万以下的，而 32 位有符号整数，最大可以到 20 亿。所以这样的计算在 32 位还是 64 位中没有什么区别。
>
> 还有一点要注意，32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如说你有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 232 个内存地址，也就是 4G 内存地址。

---
> **约翰·冯·诺依曼**
>
> <img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.5 冯诺依曼.png" alt="图1.2.5 冯诺依曼" loading="lazy" />
>
> 约翰·冯·诺依曼（John von Neumann，1903年12月28日-1957年2月8日），美籍匈牙利数学家、计算机科学家、物理学家，是20世纪最重要的数学家之一。 冯·诺依曼是罗兰大学数学博士，是现代计算机、博弈论、核武器和生化武器等领域内的科学全才之一，被后人称为“现代计算机之父”、“博弈论之父”。
>
> 冯·诺依曼先后执教于柏林大学和汉堡大学，1930年前往美国，后入美国籍。历任普林斯顿大学教授、普林斯顿高等研究院教授，入选美国原子能委员会会员、美国国家科学院院士。早期以算子理论、共振论、量子理论、集合论等方面的研究闻名，开创了冯·诺依曼代数。冯·诺依曼第二次世界大战期间曾参与曼哈顿计划，为第一颗原子弹的研制作出了贡献。
>
> 冯·诺依曼1944年与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，是博弈论学科的奠基性著作。 晚年，冯·诺依曼转向研究自动机理论，著有对人脑和计算机系统进行精确分析的著作《计算机与人脑》（1958年），为研制电子数字计算机提供了基础性的方案。 其余主要著作有《量子力学的数学基础》（1926年）、《经典力学的算子方法》、《连续几何》（1960）等。

## 1.2.2 从程序到二进制代码

看完硬件，我们来看程序。

下面展示的是在C语言的经典教材`K&R`里，Kernighan和Ritchie使用的`hello`程序。

```c
#include <stdio.h>

int main() 
{
    printf("hello world!\n");
    return 0;
}
```

我们的系统研究之路是通过追踪`hello`程序的生命周期开始的：从创建`hello`程序开始，直到该程序在系统上运行，输出简单的消息，终止结束。

沿着该程序的生命周期，我们会简要介绍一些会用到的核心概念、术语、组成部分等。在后面的章节里，我们会拓展这些思想。

### **(1)**    **信息=位+上下文**

程序`hello`以源文件`hello.c`开始它的生命。

源文件`hello.c`是由位序列组成，每个位的值要么是0，要么是1。每个字节表示源程序中的一个文本字符。

大部分计算机系统使用ASCII标准来表示文本字符，ASCII标准使用一个唯一的、字节大小的整数值来表示一个字符。图1.2.6展示了`hello.c`的ASCII表示。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.6 源文件hello.c的ASCII文本表示.png" alt="图1.2.6 源文件hello.c的ASCII文本表示" loading="lazy" />


`hello.c`是以字节序列形式保存在一个文件里的。每个字节有一个整数值，该整数值对应一个字符。比如，第一个字节的整数值是35，对应字符`#`。第2个字节的整数值是105，对应的字符是`i`。注意，每个文本行以不可见的新行符`\n`结尾，新行符`\n`对应的整数值是10。

诸如`hello.c`等由大量ASCII字符组成的文件叫文本文件，所有其他文件叫二进制文件。

源文件`hello.c`的表示展示了一个基本思想：**在一个系统里的所有信息都用bit位来表示，比如磁盘文件、存储在内存中的程序、存储在内存中的用户数据以及跨网络传输的数据等**。唯一可用来区分不同数据对象之间的是我们使用数据对象的上下文。比如，在不同的上下文里，相同的字节序列可表示一个整数、浮点数、字符串或者一个机器指令。

作为程序员，我们需要理解数字的机器表示，因为计算表示的数字跟数学上的整数和实数不一样。**计算机表示的数字是对数学上的数的有限近似**。我们将在第2章中详细地探讨这种基本思想。

### **(2)**   **源程序被其他程序转换成不同的形式**

`hello`程序以高级C程序开始，因为这种形式能被人类阅读和理解。但是，为了在系统上运行`hello.c`，每条C语句首先必须被其他程序转换成低级的机器语言指令。然后将这些机器语言指令打包成可执行目标文件，保存在一个二进制磁盘文件里。

在Unix系统上，从源文件到目标文件的转换是受编译器驱动执行的：

```
linux>gcc -o hello hello.c
```

这里，GCC编译器驱动读取文件`hello.c`，将它转换成可执行目标文件`hello`。

从源文件到可执行目标文件要经历4个过程：

1. 预处理阶段：预处理器cpp根据以`#`号开头的预处理器指令来修改最初的C程序。比如，在`hello.c`里第一行的`#include<stdio.h>`告诉预处理器读取系统头文件`stdio.h`里的内容直接插入源程序文本中。结果是另一个C程序`hello.i`。
2. 编译阶段：编译器cc1将文本文件hello.i转换成文本文件hello.s。hello.s文件中包含一个汇编语言程序，包括了main函数的定义：

```
main:
	subq  $8, %rsp
	movl  $.LC0, %edi
	call  puts
	movl  $0, %eax
	addq  $8, %rsp
	ret
```

在这个定义里的第2-7行的每一行以文本形式描述了一个底层的机器语言指令。汇编语言非常有用，因为汇编语言为不同语言的不同编译器提供一个公共的输出语言。比如，C编译器和Fortran编译器都使用相同的汇编语言生成输出文件。

3. 汇编阶段：汇编程序as将hello.s转换成机器语言指令，按照可重定向目标程序的格式来打包机器语言指令，把结果存储在目标文件hello.o中。hello.o文件是一个二进制文件，包含了17个字节，用于main函数的指令编码。如果我们使用文本编辑器打开hello.o文件，则会出现乱码。
4. 链接阶段：注意到hello程序调用了printf函数，其中printf函数是由每个C编译器提供的C标准库的一部分，驻留在一个单独的预编译号的目标文件printf.o里。链接器处理的就是printf.o文件跟hello.o程序的合并。结果是hello可执行目标文件：可被加载进内存，被系统执行。

图1.2.7展示了转换的四个阶段。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.7 编译过程示意.png" alt="图1.2.7 编译过程示意" loading="lazy" />

### **(3)**   **理解编译系统如何工作是值得的**

下图就是编译这段代码的过程：

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.8 代码编译过程示意.png" alt="图1.2.8 代码编译过程示意" loading="lazy" />

其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：

```
gcc HelloWorld.c -E -o HelloWorld.i 
gcc HelloWorld.c -S -c -o HelloWorld.s 
gcc HelloWorld.c -c -o HelloWorld.o 
gcc HelloWorld.c -o HelloWorld 
```

四行代码分别表示：

* 预处理：加入头文件，替换宏。

* 编译：包含预处理，将 C 程序转换成汇编程序。

* 汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。

* 链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。

## 1.2.3 代码的计算机之旅

### **(1)**   **处理器读取和解释存储在内存中的指令**

现在，我们的hello.c源程序已被编译系统转换成存储在磁盘上的可执行目标文件hello。为了在Unix系统上运行hello，我们在shell程序里键入它的名字：

```
linux> ./hello 
hello, world
linux>
```

Shell程序是一个命令行解释器：输出一个提示符，等待着你在命令行上键入命令，然后执行命令。如果命令里的第一个词并不对应一个内置的shell命令，则shell会假设它是一个应该被shell程序加载和运行的可执行目标文件的名字。所以，在这种情况下，shell程序就加载和运行hello程序，然后等着hello程序运行结束。hello程序在屏幕上输出消息后结束运行。shell程序然后输出一个提示符，等待着下一个命令行输入。

处理器是一个执行保存在主内存中的指令的引擎，其核心是程序计数器。程序计数器是一个存储单元是字大小的存储设备。在任何一个时间点，程序计数器都指向在主内存中的某个机器指令。

从系统加电到电源关闭，处理器重复执行由程序计数器指向的指令，更新程序计数器的值为下一条指令的地址。处理器似乎是根据由指令集架构定义的非常简单的执行模型来运作的。在这种模型里，指令按照严格的顺序来执行，执行单条指令可能需要若干步：

* 处理器从程序计数器指向的内存处读取指令；

* 解释指令中的位；

* 根据指令的指示执行简单的操；

* 然后更新程序计数器的值指向下一条指令的地址，注意下一条指令的地址可能不跟先前执行的指令在内存中是连续的。

存在一些只围绕主内存、寄存器文件、ALU运行的简单指令。寄存器问文件是一个小型设备，由存储单元是字大小的寄存器组成，每个寄存器都有唯一的名字。ALU用来计算新的数据和地址值。这里有一些CPU执行的简单操作示例：

* Load操作：从主内存中拷贝一个字节或者一个字到寄存器，副作用是会覆盖先前在寄存器中的内容。

* Store操作：从寄存器中拷贝一个字节或者一个字到主内存中的位置，副作用是会覆盖那个位置先前的内容。

* Operate操作：拷贝两个寄存器的值到ALU中，对这两个字执行算术操作，把结果存储到某个寄存器中，副作用是会覆盖那个寄存器先前的值。

* Jump操作：从指令中抽取一个字，拷贝该字到程序计数器中，副作用是会覆盖PC中先前的值。

虽然我们说处理器似乎是指令集架构的一个简单实现，但实际上现代处理器使用了更复杂的机制来加速程序执行。因此，我们可以要区分处理器的指令集架构和微架构，其中指令集架构描述了每个机器指令的作用，微体系架构描述了处理器实际上是如何实现的。当我们在第3章里研究机器码时，我们将会考虑由机器的指令集架构提供的抽象机制。第4章会对处理器实际上是如何实现的做更多的介绍。第5章描述了一个处理器是如何工作的模型，该模型使得预测和优化机器语言的程序的性能成为可能。

### **(2)**   **运行hello程序**

有了系统硬件组织和操作的简单视图，我们就能理解运行hello程序时发生了什么。我们必须省略许多细节留待后面来补充，但是现在我们将对整体情况感到满意。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.9 从键盘上读取hello命令.png" alt="图1.2.9 从键盘上读取hello命令" loading="lazy" />

最初，shell程序在执行指令，等待着我们键入命令。如图1.2.9所示，随着我们键入字符`./hello`，shell程序将每个字符读入一个寄存器，然后把字符存储在内存中。

当我们敲击enter键时，shell程序知道我们已完成命令的键入。然后，shell程序执行一系列指令，将hello可执行目标文件里的代码和数据从磁盘拷贝到内存。包含`hello, world\n`的数据最终将被打印输出。

如图1.2.10所示，可使用DMA技术将数据直接从磁盘传输到内存，不需用经过处理器。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.10 从磁盘加在可执行文件到主存.png" alt="图1.2.10 从磁盘加载可执行文件到主存" loading="lazy" />

如图1.2.11所示，一旦hello目标文件的代码和数据被加载到内存，处理器就开始执行在hello程序里的main函数里的机器指令。这些指令将字符串`hello, world\n`中的字节从内存拷贝到寄存器文件，然后从寄存器文件拷贝到显示器上，在显示器上输出该字符串。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.11 将输出字符串从存储器写到显示器.png" alt="图1.2.11 将输出字符串从存储器写到显示器" loading="lazy" />

## 1.2.4 小结

程序的执行与计算机硬件架构紧密相连，冯诺依曼体系结构已成为目前最为广泛使用的计算机体系架构，它将计算机抽象成输入、输出、存储、CPU（计算器、控制器）等部分，为了数据和控制信号关联各部件，还需要总线支持。

程序是计算机的灵魂，我们一般采用高级语言编写程序，为了让计算机能够看懂和执行，需要将高级语言程序编译成计算机二进制代码，这就需要编译系统，一般经过预处理、编译、汇编和链接四个大的步骤。程序编译好之后放在存储器上，当需要执行程序的是时候，CPU首先把程序载入内存，然后一条条获取程序指令和数据，并将运算结果写入内存。我们将在后续章节详细介绍这个执行过程。

<img src="https://ebook2023.oss-cn-shanghai.aliyuncs.com/图1.2.13计算机模型与程序执行.png" alt="图1.2.13 计算机模型与程序执行" loading="lazy" />