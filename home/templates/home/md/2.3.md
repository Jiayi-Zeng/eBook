# 2.3 二进制运算

## 2.3.1 补码的加法

对于正数，它的补码是它本身，对于负数，它的补码是它的反码+1，那么对于一个n位的二进制数x，它的补码是(x+2^n)mod 2^n，这对正数和负数都适用，所以我们可以将[x+y]补转换成[x]补+[y]补，即[x+y]补=[x]补+[y]补，证明如下：

[x]补+[y]补=(2^n+x)mod 2^n + (2^n+y)mod 2^n

=(2^n+x + 2^n+y)mod 2^n

=(2^n + (x+y))mod 2^n

=[x+y]补


下面分情况给出几个例子，分别通过补码运算来得到最终结果。

## (1) 正数+负数

假设我们使用8位补码表示有符号整数，有两个数要相加：5+(-3)。

首先将数字转换为二进制表示（原码），最高位是符号位，正数的符号位是0，负数的符号位是1：

原码：5=0000 0101     -3 =1000 0011

<div>
    <iframe src="/#/anim/1"></iframe>
    <iframe src="/#/anim/2"></iframe>
</div>
<video controls class="markdown-video">
  <source src="/md/e9d97873e96adacc424b58d0dca93ecf.mp4" type="video/mp4" />
</video>

然后转换为反码，正数的反码是它本身，负数的反码是除了符号位以外，其余位取反：

原码：5=0000 0101     -3=1111 1100

![img](https://gitee.com/Jiayi-Zeng/picgo_markdown/raw/master/pic/%E5%9B%BE%E7%89%872%20(2).png)

最后转换为补码，正数的补码是它本身，负数的补码是反码加1

补码：5=0000 0101     -3=1111 1100 + 1 = 1111 1101

![img](https://gitee.com/Jiayi-Zeng/picgo_markdown/raw/master/pic/%E5%9B%BE%E7%89%872%20(3).png)

接下来执行加法运算：

![img](https://gitee.com/Jiayi-Zeng/picgo_markdown/raw/master/pic/%E5%9B%BE%E7%89%872%20(4).png)

1 0000 0010有进位，舍弃进位1。

所以，补码是0000 0010表示的是一个正数。首位为0，表示正号。

正数的补码=原码，所以原码也是0000 0010，转换为十进制是2.

## (2) 正数+正数

计算 3 + 2。

转换为二进制表示（原码）：

原码：3=0000 0011     2=0000 0010

反码是原码本身。

补码是原码本身。

执行加法运算：

![img](https://gitee.com/Jiayi-Zeng/picgo_markdown/raw/master/pic/%E5%9B%BE%E7%89%872%20(5).png)

补码0000 0101表示的是一个正数。首位为0，表示正号。

正数的补码=原码，所以原码也是0000 0101，转换为十进制是5.

## (3) 负数+负数

计算 -3 + (-2)。

转换为二进制表示（原码）：

原码：-3=1000 0011     -2=1000 0010

反码：-3=1111 1100     -2=1111 1101

补码：-3= 1111 1100 + 1 = 1111 1101 -2= 1111 1101 + 1 = 1111 1110

执行加法运算：

![img](https://gitee.com/Jiayi-Zeng/picgo_markdown/raw/master/pic/%E5%9B%BE%E7%89%872%20(6).png)

1 1111 1011有进位，舍弃进位1。

所以，补码是1111 1011表示的是一个负数。首位为1，表示负号。

反码 = 补码 - 1 = 1111 1011 - 1 = 1111 1010

故，原码 = 1000 0101，转换为十进制是 -5。

<iframe class="iframe-question" src="/#/question/1"></iframe>

## 2.3.2 补码的减法

对于正数，它的补码是它本身，对于负数，它的补码是它的反码+1，那么对于一个n位的二进制数x，它的补码是(x+2^n)mod 2^n，这对正数和负数都适用，所以我们可以将[x+y]补转换成[x]补+[y]补，即[x+y]补=[x]补+[y]补，证明如下：

[x]补+[y]补=(2^n+x)mod 2^n + (2^n+y)mod 2^n

=(2^n+x + 2^n+y)mod 2^n

=(2^n + (x+y))mod 2^n

=[x+y]补

即先将y变换为-y，比如3，就变换为-3，然后就和上面的补码加法的各种情况类似了，这里就不再举例展示了。

<iframe class="iframe-question" src="/#/question/2"></iframe>


## 2.3.3 溢出问题

在补码相加时，符号位产生的进位要自然舍弃，这是为了保证运算的正确性和一致性，也是因为bit长度的限制。但这时我们会注意到另外一个问题：数值溢出。看下面这个例子：

假设我们用8位二进制数表示有符号整数，那么它的范围是-128到127。如果要计算-80-50，那么需要先求出-80和-50的补码，然后相加：

-80的原码是11010000，补码是10110000， -50的原码是10110010，补码是11001110，两者相加得到：

![img](https://gitee.com/Jiayi-Zeng/picgo_markdown/raw/master/pic/%E5%9B%BE%E7%89%872%20(7).png)

如果舍弃进位1，那么最终结果是0111 1110，这明显是一个正数，完全不符合我们所预想的结果。其实通过十进制的运算我们也能发现，-80-50结果是-130，超出了8位有符号二进制数的表示范围，这种情况就叫做溢出。

溢出应该如何判断呢？这里给出一种方法：双符号位判断溢出

正数的符号位为00，负数的符号位为11，在相加得到结果后，如果符号位不同，则发生了溢出。例如符号位变成01，则表示正确的符号位为0，实际的符号位为1，发生了上溢。

